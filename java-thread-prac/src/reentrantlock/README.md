# Lock 인터페이스와 ReentrantLock 구현체

- synchronized에 존재하는 문제 : 무한 대기 문제, 공정성 문제
- ReentrantLock은 위 두 문제를 잘 해결해줌
- lock()의 경우 인터럽트가 불가능하지만 lockInterruptibly()를 이용하여 인터럽트가 가능하게 만들어줌
- ReentrantLock의 lock은 객체 모니터 락이 아니라 해당 구현체의 고유 기능적인 lock
- 모니터 락은 synchronized에서만 사용되는 BLOCKED 상태를 기반한 LOCK
- lock()은 WAITING상태, lock(time, timeUnit)은 TIMED_WAITING 상태
- lock() - unlock() 사이에 임계영역에 해당하는 코드 작성하면 된다.(예제에서 경험하기)
- unlock()은 임계영역이 끝나고 무조건 실행되어야 하기에, try-finally로 어떤 경우든 실행되게끔 작성해야함.
- ReentrantLock(true)를 이용하면 락 획득에 있어서 공정하게 먼저 들어온 스레드에 락을 넘겨주도록 함.
- 공정성은 기본적으로 false 상태
- 우리는 대부분 false 상태를 이용해야함.
- 그 이유는 비공정 상태여도 대부분 문제 없이 순서대로, 가끔 후에 온 스레드가 먼저 락을 얻을 뿐 크게 문제되는 경우가 없기 때문
- true를 사용해야만 할 때는 다음과 같음 : 무조건적으로 들어온 순서를 유지해야할 경우 -> 이때 말고는 이용할 필요는 없다.
- tryLock()은 락 획득이 가능하면 락을 획득하고 true를 반환, 락 획득이 불가능하면 false 반환

# 멀티스레드 카페 주문 처리 시스템 구현하기

---

## 배경

한 카페에서는 주문이 여러 손님으로부터 동시에 들어온다.  
주문을 받고, 음료를 만드는 과정에서 동시성 문제가 발생할 수 있다.  
특히 재고 수량을 관리하는 부분에서 데이터 경쟁(race condition)이 발생하지 않도록 해야 한다.

---

## 요구사항

1. `CoffeeShop` 클래스 구현
    - 필드: `inventory` (현재 재고 수량, int 타입)
    - 메서드:
        - `orderCoffee(int amount)`
            - 주문 수량 만큼 재고를 줄임
            - 재고가 부족하면 주문 실패를 출력
            - 주문 성공 시 주문 내역과 남은 재고 출력

2. 멀티스레드 환경에서 5개의 손님(스레드)이 각기 다른 주문량으로 동시에 주문을 넣음
3. `orderCoffee` 메서드에 `ReentrantLock`을 이용해 동기화 처리
4. `tryLock()`도 활용해 락을 얻지 못하면 “바쁘니 잠시만 기다려주세요” 메시지를 출력하고 재시도하지 않고 종료
5. 각 주문 스레드는 주문 성공 여부를 출력

---

## 추가 힌트

- `ReentrantLock`을 활용해 재고 감소 로직을 안전하게 처리할 것
- `tryLock()`으로 락을 얻지 못한 스레드는 대기 없이 바로 실패 처리
- `unlock()`은 반드시 `finally` 블록에서 호출할 것

---

## 과제

이 요구사항에 맞는 Java 코드를 작성하세요.