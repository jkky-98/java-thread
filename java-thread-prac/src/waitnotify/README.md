# 🔒 `wait()` / `notify()` 없이 Lock만 사용할 때 발생하는 문제

멀티스레드 환경에서 공유 자원(예: 버퍼)을 사용하는 **생산자-소비자 문제**를 `wait()`와 `notify()` 없이, 단순히 `synchronized` 블록과 `sleep()`만으로 구현할 경우 다음과 같은 문제가 발생할 수 있다.

---

## 🧨 문제: **Lock을 들고 무한히 기다리는 상황 발생**

생산자나 소비자가 자원이 부족하거나 조건이 맞지 않는 상황(예: 버퍼가 가득 찼거나 비었을 때)에 진입한 후,  
`wait()` 없이 `sleep()` 또는 무한 루프(`while(...) {}`)로 대기하게 되면,  
해당 스레드는 **lock을 해제하지 않고 계속 점유한 채** 대기 상태에 머물게 된다.

이로 인해 다른 스레드는 자원에 접근할 수 없으며, 결과적으로 시스템이 멈추게 된다.

---

## ⛔ 결과적으로 발생하는 현상

- 자원의 상태는 바뀌지 않고 유지된다.
- 다른 스레드는 lock을 획득하지 못해 대기 상태로 머무른다.
- 서로가 서로의 작업을 기다리게 되면서,
- 시스템은 **데드락(Deadlock)** 또는 **무한 대기 상태**에 빠지게 된다.

---

## ✅ `wait()` / `notify()`의 필요성

`wait()`는 조건이 충족되지 않을 경우, **lock을 해제하고 대기 상태로 전환**할 수 있게 한다.  
이후 자원의 상태가 바뀌었을 때, `notify()`를 통해 적절한 스레드를 **깨워 다시 lock을 획득하고 실행**할 수 있게 한다.  
이를 통해 **lock을 점유한 채 무한히 기다리는 문제**를 방지할 수 있다.

---

## 📌 요약

> `wait()` 없이 단순한 sleep이나 polling 방식으로 대기할 경우,  
> 스레드가 lock을 쥔 채로 무한히 기다리게 되어  
> 다른 스레드가 자원 상태를 변경할 기회를 잃게 된다.  
> 그 결과, 전체 시스템이 멈추는 심각한 문제가 발생할 수 있다.


# 생산자-소비자 문제: Java 멀티스레드 실습 과제

## 🧩 실습 과제 개요

생산자-소비자 문제는 멀티스레드 환경에서 공유 자원을 안전하게 접근하는 방법과 스레드 간 협력을 배우는 핵심 주제입니다. 이 실습에서는 제한된 버퍼를 사용하는 생산자-소비자 구조를 직접 구현해봅니다.

---

## 🎯 목표

- `wait()` / `notify()`를 사용한 스레드 간 동기화 학습
- 공유 자원(버퍼)에 대한 임계 구역 관리
- 생산자-소비자 구조의 병렬 동작 이해
- 교착 상태, 데이터 손실, 비효율적 신호 전달 등의 문제 탐색

---

## 🛠️ 과제 설명

### 조건

1. **버퍼**는 최대 5개의 정수만 저장 가능한 유한 큐로 구현
2. **생산자 스레드**는 0~100 사이의 랜덤 정수를 생성해 버퍼에 저장
3. **소비자 스레드**는 버퍼에서 정수를 꺼내 콘솔에 출력
4. 생산자 또는 소비자는 **버퍼가 가득 차거나 비어 있으면 대기**
5. `wait()`, `notify()` 또는 `notifyAll()`을 통해 동기화 구현
6. 각각 2개 이상의 생산자와 소비자 스레드를 생성할 것
7. 프로그램은 5초~10초 동안 동작한 후 종료되도록 구현

---

## 구현 및 테스트 결과

100 put, 100 take, 5buffer, notify : 189(put먼저), 199(take먼저) 
10 put, 10 take, 5buffer, notify : 8(put먼저), 18(take먼저)
100 put, 100 take, 5buffer, notifyAll : 248(put먼저), 511(take먼저)
10 put, 10 take, 5buffer, notifyAll : 8(put먼저), 24(take먼저)
1000 put, 1000 take, 5buffer, notify : 1989(put먼저), 1999(take먼저)

## 의의

10put / 10take는 waitCount가 8~24로 매우 적음 → 충돌이 적고 간단한 실행 구조

100put / 100take에서는 waitCount가 100~500으로 급증 → 스레드 경쟁 증가 + 대기/깨어남 반복 심화

특히 notifyAll()을 쓸 경우, 모든 스레드가 반복해서 깨어나므로 그 횟수가 폭발적으로 늘어남

take를 먼저 시작하면, 초기 버퍼가 비어있어 소비자 스레드가 바로 wait()에 들어감.

반면, put을 먼저 시작하면, 버퍼가 꽉 찼을 가능성이 높아서 생산자 스레드가 wait()하게 됨.

notifyAll()을 쓰는 상황에서는 특히 take를 먼저 시작할 경우, 초기부터 다수의 소비자가 대기하게 되어 깨어나는 횟수가 더 많아지는 경향이 있음.

## wait/notify 구조의 한계

`생산자 or 소비자 무엇을 깨우는지에 대한 것이 랜덤`이기 때문에 스레드가 많아질수록 다시 wait 상태로 들어가는 경우도 기하급수적으로 많아져

성능적으로 불리하다.