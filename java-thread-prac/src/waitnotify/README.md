# 생산자-소비자 문제: Java 멀티스레드 실습 과제

## 🧩 실습 과제 개요

생산자-소비자 문제는 멀티스레드 환경에서 공유 자원을 안전하게 접근하는 방법과 스레드 간 협력을 배우는 핵심 주제입니다. 이 실습에서는 제한된 버퍼를 사용하는 생산자-소비자 구조를 직접 구현해봅니다.

---

## 🎯 목표

- `wait()` / `notify()`를 사용한 스레드 간 동기화 학습
- 공유 자원(버퍼)에 대한 임계 구역 관리
- 생산자-소비자 구조의 병렬 동작 이해
- 교착 상태, 데이터 손실, 비효율적 신호 전달 등의 문제 탐색

---

## 🛠️ 과제 설명

### 조건

1. **버퍼**는 최대 5개의 정수만 저장 가능한 유한 큐로 구현
2. **생산자 스레드**는 0~100 사이의 랜덤 정수를 생성해 버퍼에 저장
3. **소비자 스레드**는 버퍼에서 정수를 꺼내 콘솔에 출력
4. 생산자 또는 소비자는 **버퍼가 가득 차거나 비어 있으면 대기**
5. `wait()`, `notify()` 또는 `notifyAll()`을 통해 동기화 구현
6. 각각 2개 이상의 생산자와 소비자 스레드를 생성할 것
7. 프로그램은 5초~10초 동안 동작한 후 종료되도록 구현

---

## 구현 및 테스트 결과

100 put, 100 take, 5buffer, notify : 189(put먼저), 199(take먼저) 
10 put, 10 take, 5buffer, notify : 8(put먼저), 18(take먼저)
100 put, 100 take, 5buffer, notifyAll : 248(put먼저), 511(take먼저)
10 put, 10 take, 5buffer, notifyAll : 8(put먼저), 24(take먼저)

## 의의

10put / 10take는 waitCount가 8~24로 매우 적음 → 충돌이 적고 간단한 실행 구조

100put / 100take에서는 waitCount가 100~500으로 급증 → 스레드 경쟁 증가 + 대기/깨어남 반복 심화

특히 notifyAll()을 쓸 경우, 모든 스레드가 반복해서 깨어나므로 그 횟수가 폭발적으로 늘어남

take를 먼저 시작하면, 초기 버퍼가 비어있어 소비자 스레드가 바로 wait()에 들어감.

반면, put을 먼저 시작하면, 버퍼가 꽉 찼을 가능성이 높아서 생산자 스레드가 wait()하게 됨.

notifyAll()을 쓰는 상황에서는 특히 take를 먼저 시작할 경우, 초기부터 다수의 소비자가 대기하게 되어 깨어나는 횟수가 더 많아지는 경향이 있음.

## wait/notify 구조의 한계

`생산자 or 소비자 무엇을 깨우는지에 대한 것이 랜덤`이기 때문에 스레드가 많아질수록 다시 wait 상태로 들어가는 경우도 기하급수적으로 많아져

성능적으로 불리하다.