# Executor

## 여태까지의 멀티 스레드 사용 방법
- new Thread()를 통해 직접 스레드를 생성하고 Runnable task를 주어 .start()로 실행
- 실제로 스레드 객체 하나를 생성하는데 걸리는 비용이 크다.(시간적으로도, 메모리 용량적으로도)
- 스레드 객체를 생성할 때 운영체제 자원 및 메모리 할당등 많은 것들이 이루어지기 때문
- Executor 프레임워크는 이에 대한 대안
- 보통 스레드 Pool 방식을 사용해서 스레드를 미리 생성해놓고 관리한다.
- 스레드 풀 방식은 스레드를 초기에 미리 생성해놓고 작업이 들어오면 관리되는 스레드와 매칭시켜 작업을 실행시키는 방식
- 기존 방식인 작업 생성시 스레드도 함께 생성하여 스레드에 작업을 먹여 실행하는 방식에서 스레드를 생성하는 과정을 줄여준다
- 스레드를 단순히 컬렉션에 모아놓고 직접 운영하는 것은 매우 어려운 일이기 때문에 이러한 라이브러리를 사용한다.
- 스레드 풀을 지원하는 ExecutorService 같은 경우 단순히 스레드를 모아놓는거 이외에 스레드 수를 조건에 따라 일정 시간 늘린다던지 모두 종료시킨다던지의 편의적인 기능을 대부분 구현하고있다.
- 즉 실전에서 스레드를 직접 만들어서 사용하는 경우는 거의 없다. 멀티스레드를 코딩한다면 무조건 Executor 프레임워크를 활용하여 코딩하게 될 것이다.

## 직접 스레드를 컨택할 수 없다면 .join() 과 같은 기능들이 필요할 때는 어떻게 해야하나?
- 후에 서술할 Future + Callable을 활용하면 이 또한 손쉽게 처리 가능

## Runnable의 단점 극복 가능
- 기존의 Runnable은 반환이 불가능한 run() 메서드를 기본으로 하기에 반환값을 받는 것이 불가능 했다.
- Callable은 가능
- 또한 예외의 경우 체크예외를 던질 수 없다는 불편함이 있었으나 Callable에서 이 부분또한 개선

## ExecutorServiceMain

이전 방식인 100개의 스레드를 생성하고 간단한 콘솔 출력 작업을 수행하는 Runnable 태스크 100개를 스레드에 올려 실행할때까지의 시간을
스레드 풀에서 100개의 스레드를 관리하며 100개의 같은 태스크를 매칭시켜 실행하는 데 까지의 시간을 비교

### 스레드 풀(100개 스레드) - 100개 태스크 vs 스레드100개 생성 - 100개 태스크
2025-08-18 14:52:00.475 [     main] ExecutorService 작업 총 실행 시간 = 33ms
2025-08-18 14:52:00.476 [     main] 바닐라 작업 실행 시간 = 98ms

약 3배 차이

### 스레드 풀(100개 스레드) - 1000개 태스크 vs 스레드1000개 생성 - 1000개 태스크 
2025-08-18 15:05:19.601 [     main] ExecutorService 작업 총 실행 시간 = 34ms
2025-08-18 15:05:19.601 [     main] 바닐라 작업 실행 시간 = 358ms

약 100배 차이

### 실험 의의
스레드 생성에 대한 비용이 꽤 크다는 것

그에 반해 스레드가 일을 처리하는 속도는 비교적 매우 작을 수 있다는 것을 참고하면,

스레드를 미리 생성해놓고 작업 수에 비해 매우 적은 스레드를 운용하면서 이들이 많은 작업들을 처리하게 하는 것이 가장 일반적인 효율을 보여줄 것으로 예상. 