# Executor

## 여태까지의 멀티 스레드 사용 방법
- new Thread()를 통해 직접 스레드를 생성하고 Runnable task를 주어 .start()로 실행
- 실제로 스레드 객체 하나를 생성하는데 걸리는 비용이 크다.(시간적으로도, 메모리 용량적으로도)
- 스레드 객체를 생성할 때 운영체제 자원 및 메모리 할당등 많은 것들이 이루어지기 때문
- Executor 프레임워크는 이에 대한 대안
- 보통 스레드 Pool 방식을 사용해서 스레드를 미리 생성해놓고 관리한다.
- 스레드 풀 방식은 스레드를 초기에 미리 생성해놓고 작업이 들어오면 관리되는 스레드와 매칭시켜 작업을 실행시키는 방식
- 기존 방식인 작업 생성시 스레드도 함께 생성하여 스레드에 작업을 먹여 실행하는 방식에서 스레드를 생성하는 과정을 줄여준다
- 스레드를 단순히 컬렉션에 모아놓고 직접 운영하는 것은 매우 어려운 일이기 때문에 이러한 라이브러리를 사용한다.
- 스레드 풀을 지원하는 ExecutorService 같은 경우 단순히 스레드를 모아놓는거 이외에 스레드 수를 조건에 따라 일정 시간 늘린다던지 모두 종료시킨다던지의 편의적인 기능을 대부분 구현하고있다.
- 즉 실전에서 스레드를 직접 만들어서 사용하는 경우는 거의 없다. 멀티스레드를 코딩한다면 무조건 Executor 프레임워크를 활용하여 코딩하게 될 것이다.

## 직접 스레드를 컨택할 수 없다면 .join() 과 같은 기능들이 필요할 때는 어떻게 해야하나?
- 후에 서술할 Future + Callable을 활용하면 이 또한 손쉽게 처리 가능

## Runnable의 단점 극복 가능
- 기존의 Runnable은 반환이 불가능한 run() 메서드를 기본으로 하기에 반환값을 받는 것이 불가능 했다.
- Callable은 가능
- 또한 예외의 경우 체크예외를 던질 수 없다는 불편함이 있었으나 Callable에서 이 부분또한 개선

### Runnable을 개선해서 재출시 하면 되지 않나?
- 후방호환성을 고려한 것(이미 많은 코드에서 Runnable이 기존 버전에 맞추어 사용중이었음)
- Runnable이 나올 당시에는 제네릭이 없었기때문에 Callable이 지원하는 제네릭을 활용한 자유반환 방식이 고려될 수 없었음
- 어쨌든 반환가능한 Callable, 반환 불가능한 Runnable 이렇게 명확히 기능 분리가 되는 것이기에 Callable이 새로 생긴다해도 문제가 될 지점은 없었음

## ExecutorServiceMain

이전 방식인 100개의 스레드를 생성하고 간단한 콘솔 출력 작업을 수행하는 Runnable 태스크 100개를 스레드에 올려 실행할때까지의 시간을
스레드 풀에서 100개의 스레드를 관리하며 100개의 같은 태스크를 매칭시켜 실행하는 데 까지의 시간을 비교

### 스레드 풀(100개 스레드) - 100개 태스크 vs 스레드100개 생성 - 100개 태스크
2025-08-18 14:52:00.475 [     main] ExecutorService 작업 총 실행 시간 = 33ms
2025-08-18 14:52:00.476 [     main] 바닐라 작업 실행 시간 = 98ms

약 3배 차이

### 스레드 풀(100개 스레드) - 1000개 태스크 vs 스레드1000개 생성 - 1000개 태스크 
2025-08-18 15:05:19.601 [     main] ExecutorService 작업 총 실행 시간 = 34ms
2025-08-18 15:05:19.601 [     main] 바닐라 작업 실행 시간 = 358ms

약 100배 차이

### 실험 의의
스레드 생성에 대한 비용이 꽤 크다는 것

그에 반해 스레드가 일을 처리하는 속도는 비교적 매우 작을 수 있다는 것을 참고하면,

스레드를 미리 생성해놓고 작업 수에 비해 매우 적은 스레드를 운용하면서 이들이 많은 작업들을 처리하게 하는 것이 가장 일반적인 효율을 보여줄 것으로 예상.


# 커머스 주문 시스템 예제

- 이 주문 시스템은 Bad 버전과 Good 버전, Very Bad을 구현해야한다.

하나의 주문이 발생하면 3가지 작업을 수행해야한다
- updateStock(orderNo) : 재고를 업데이트 해야한다. 최소 1ms 소요 필요
- updateShipping(orderNo) : 배송 시스템에 이 주문을 알려야 한다. 최소 1ms 소요 필요
- updateAccount(orderNo) : 회사 회계 시스템에 판매 데이터를 업데이트 해야한다. 최소 1ms 소요 필요
- 위의 메서드명은 자유수정 가능

Bad : Thread를 직접 다루는 경우(ExecutorService 사용 X)
Good : Future + Callable을 활용한 이상적인 코드
Very Bad : Future + Callable을 활용하지만, get()을 모든 제출이 끝나지 않은 도중에 사용하여 비효율적으로 기다리는 코드

멀티스레드의 경우 ExecutorService를 활용하도록 하자.

주문 작업은 100개를 만들어 실행한다.

작업이 모두 처리되는 시간을 최종적으로 로그에 찍어야하며, 작업이 처리되는 과정또한 로그로 찍어보자.

## 결과

### Bad
2025-08-18 18:45:00.348 [     main] total time = 134ms
### Good
2025-08-18 18:45:11.960 [     main] total time = 103ms
### Very Bad
2025-08-18 18:45:19.811 [     main] total time = 284ms

## 결과 분석
Bad 와 Good의 차이는 스레드 생성 시간의 차이가 보인다.

Very Bad의 경우 for 루프 도중 get()을 호출하여 다음 제출을 막는 경우이다.

이 경우 병목이 생겨 사실상의 멀티스레드 기능을 하지 못한다.