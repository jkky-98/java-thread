# LockSupport

## 배경 설명
Java 1.5에서는 기존의 synchronized, wait/notify 방식으로는 
세밀한 스레드 제어와 고성능 락 구현이 어렵다는 한계가 있었다.

이런 이유로 Java 1.5에서 java.util.concurrent 패키지가 도입되었고,
그 핵심 동기화 도구들의 기반이 되는 저수준 API로 LockSupport가 추가됨.

## 주요 기능 두 가지
- park() : 현재 스레드를 WAITING 상태로 대기 시킴
- unpark(Thread 객체) : 해당 쓰레드 객체를 WAITING -> RUNNABLE 상태로 전환시킴

- 만약 해당 쓰레드 객체가 RUNNABLE인데 unpark(Thread 객체) 사용한다면 해당 쓰레드에 면제권(permit)을 줌, 이 뜻은
- RUNNABLE에서 unpark()후 park()를 해도 한번은 잠들지 않음.
- permit은 최대 1개까지만 쌓이기에 unpark()를 100번하더라도 park() 101번 후에 깨는 것이 아니라 두번째 park()부터 깨어남.

## 자다 깨는 기능만 있는데 Lock 로직을 어떻게 구현한다는 걸까?
LockSupport는 Lock 로직을 위한 매우 저수준의 클래스이기에 이를 활용하여 Lock 기능을 직접 코딩해야함.
후에 서술하겠지만 당연히 LockSupport를 직접 이용하는 경우는 거의 없음.

## 그냥 자다 깨는 기능만 있다면 sleep() + interrupt()로도 구현 가능한거 아닌가?

우선 가장 큰 차이는 sleep()과 park()에 존재한다. 

sleep()은 `주어진 시간 동안 자는 것` park()는 `누가 깨워줄 때 까지 자는 것` 이다.

두 메서드의 다른 점이 꽤 크게 작용한다.

sleep()으로 lock()을 구현하면 대충 아래 코드처럼 짜야한다.

```java
    while(!tryLock()) {
        sleep(1000 * 60); 
            }
```
tryLock()은 Lock을 얻으면 true 아니면 false인 직접 구현했다고 가정한 메서드이다.

즉 이 코드를 이해해보면 1분마다 깨서 Lock 확보시도를 하는 것이다.

컴퓨터가 아닌 인간의 입장에서 생각해보자.

1분동안 자고 깨서 Lock 확보시도, 다시 1분동안 자고 깨서 Lock 확보시도.... 이런 반복이 필요하다.

매우 피폐해진다. 컴퓨터도 동일하게 이런 반복에 의해 피폐해진다.

반면 `누가 깨워줄 때 까지 자는 것`으로 구현할 경우

```java
    while(!tryLock()) {
        LockSupport.park();
            }
```
다음과 같이 구현될 것이고, 처음부터 자고 누가 깨워줄 때 까지 잔다.

이 경우 자는 도중 깰 이유는 단 하나이다. 

Lock을 획득 가능한 경우이다. 바깥에서, 다른 스레드가 Lock 획득이 가능하다고 판단되면 이 스레드를 깨워 Lock을 얻게 하는 것이다.

누군가의 도움을 받는 것은 매우 효율적이다.

1분동안 자고 깨는 것은 비용도 비용이지만 내가 잠든 직후 1초 후 Lock을 얻을 수 있는 상황이더라도 59초가 지나야만 그것을 얻을 시도를 할 수 있다.

반면 park()의 경우 Lock을 얻을 수 있는 상황에 바로 깨서 Lock을 얻을 수 있다.