# 🔄 ReentrantLock + Condition 기반 생산자-소비자 문제 실습

---

## 🎯 실습 목표

이 과제는 `wait()` / `notify()` 방식의 한계를 보완하기 위해  
`ReentrantLock`과 `Condition`을 활용하여 스레드 선택적 깨움 기능을 구현하는 것이다.

---

## 📌 배경: wait / notify 방식의 한계

### ✅ 기본 문제

- `wait()` / `notify()` 방식은 어떤 스레드를 깨울지 직접 제어할 수 없다.
- 생산자가 데이터를 넣고 `notify()`를 호출할 경우, 또 다른 생산자가 깨어나는 비효율적 상황이 발생할 수 있다.
- 스레드 수가 많아질수록 "깨어남 → 조건 불만족 → 다시 wait()"의 루프가 기하급수적으로 증가하게 된다.

### 🧨 결과

- 성능 저하와 컨텍스트 스위칭 증가가 발생한다.
- waitCount가 과도하게 증가하게 된다.

---

## ✅ 해결 방법: ReentrantLock + Condition

- `ReentrantLock`은 `synchronized`보다 정교한 락 제어가 가능하다.
- `Condition` 객체를 이용하면, 생산자와 소비자 각각을 위한 조건 대기 큐를 분리할 수 있다.
- `signal()` 호출 시, 특정 조건을 기다리는 스레드만 깨울 수 있기 때문에 효율적인 동기화가 가능하다.

---

## 🧪 실습 조건

### 🎯 구현 요구사항

1. 버퍼는 최대 5개의 정수만 저장 가능한 유한 큐로 구현해야 한다.
2. 생산자는 0~100 사이의 랜덤 정수를 생성하여 버퍼에 저장한다.
3. 소비자는 버퍼에서 정수를 꺼내 콘솔에 출력한다.
4. 버퍼가 가득 찼을 경우, 생산자는 생산자 전용 Condition.await()를 통해 대기해야 한다.
5. 버퍼가 비어 있을 경우, 소비자는 소비자 전용 Condition.await()를 통해 대기해야 한다.
6. 생산자가 put()을 완료한 후에는 소비자 Condition을 signal() 해야 한다.
7. 소비자가 take()를 완료한 후에는 생산자 Condition을 signal() 해야 한다.
8. 생산자와 소비자는 각각 2개 이상의 스레드로 구성해야 한다.
9. 프로그램은 약 5초~10초 동안 실행된 후 종료되어야 한다.

## 구현 및 테스트 결과

100 put, 100 get, 5buffer, signal : 95(put먼저), 100(get먼저)
10 put, 10 get, 5buffer, signal : 5(put먼저), 10(get먼저)

## 의의
LockCondition을 활용하여 대기 공간을 분리할 경우 wait에 빠지는 경우를 확연히 줄일 수 있었다.

소비자 스레드가 할 일을 끝내고 다음 스레드를 깨울 때 소비자 or 생산자를 깨우는게 아니라 무조건 생산자를 깨우도록 한다면

하나가 소비되면 하나가 충전되는 경향의 구도를 만들 수 있다.

# synchronized + wait/notify vs ReentrantLock + Condition 구조에서의 대기 공간 원리 차이
- 스레드가 락을 얻지 못해 대기하는 1차 대기공간과 2차 대기공간이 존재한다.
- synchronized에서는 BLOCKED 와 WAITING 상태의 차이로 이를 구분 가능하다.
- 모니터락을 얻기 위해 대기하는 BLOCKED 상태에서의 1차 대기공간
- wait에 의해 모니터락을 내어주고 WAITING으로 대기하는 2차 대기공간
- wait에 의해 대기하고있는 스레드가 notify에 의해 깨어나게되면 1차 대기공간인 BLOCKED 상태로 진입한다
- wait()에 의해 대기하고 있던 스레드는 1차적으로 notify로 하여금 깨어나야하며, 2차적으로 모니터 락을 얻어야만 임계영역(synchronized 블럭) 진입이 가능하다.
- ReentrantLock 구조에서도 1차 대기공간과 2차 대기공간이 나뉘어지지만 synchronized와의 차이점은 ReentrantLock에서는 두 대기공간 모두 WAITING으로 대기한다는 점이다.
- ReentrantLock 구조에서 condition.await()에 의해 락을 내어주고 WAITING으로 대기 한다 이때 대기하는 공간은 2차 대기공간이다.
- 2차 대기공간에서 대기중인 스레드가 condition.signal()로 깨어나게되면 1차 대기공간으로 스레드가 이주하게된다.
- 1차 대기공간에서 lock()을 얻기 위해 다시 대기한다. 얻게되면 lock.lock()~lock.unlock() 부분인 임계영역을 이어서 수행할 수 있다.

- BLOCKED와 WAITING은 실제 OS(스케줄링) - CPU(실제 실행)에서 딱히 차이가 없다. 이는 단순히 자바에서의 구분이다.
- 즉 BLOCKED도 WAITING도 OS에 의해 스케줄링을 받지않는 대기 상태인 것이다.
- 다만 차이점은 BLOCKED는 자바상의 인터럽트가 걸리지 않는다는 것이고 WAITING은 걸릴 수 있다는 것에서 차이점이 존재한다.

- synchronized와 달리 ReentrantLock 구조에서는 Condition을 여러개 두어 2차 대기공간에 대한 더 자유로운 커스텀이 가능해진다.
- 또한 lockInterruptibly()를 이용하여 인터럽트가 가능하게 만들어줄 수도 있다.
- 공정성의 여부에 있어서도 Condtion 구조가 더욱 FIFO를 지향하기에 먼저들어온 스레드가 먼저 락을 얻는 경향이 높다.

- 임계영역과 락을 다룰때 왜 1차 대기공간과 2차 대기공간을 나누었을까
- 1차 대기공간은 lock을 얻기 위한 경합을 하기위한 공간이며
- 2차 대기공간은 경합조차 허용하지 않고 잠자코 대기하기 위한 공간이다
- 즉 1차 영역은 락을 얻을 수 있는 영역이며 2차 영역은 락을 얻어서는 안되는 대기해야하는 영역인 것이다.
