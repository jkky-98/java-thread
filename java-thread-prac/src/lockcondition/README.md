# 🔄 ReentrantLock + Condition 기반 생산자-소비자 문제 실습

---

## 🎯 실습 목표

이 과제는 `wait()` / `notify()` 방식의 한계를 보완하기 위해  
`ReentrantLock`과 `Condition`을 활용하여 스레드 선택적 깨움 기능을 구현하는 것이다.

---

## 📌 배경: wait / notify 방식의 한계

### ✅ 기본 문제

- `wait()` / `notify()` 방식은 어떤 스레드를 깨울지 직접 제어할 수 없다.
- 생산자가 데이터를 넣고 `notify()`를 호출할 경우, 또 다른 생산자가 깨어나는 비효율적 상황이 발생할 수 있다.
- 스레드 수가 많아질수록 "깨어남 → 조건 불만족 → 다시 wait()"의 루프가 기하급수적으로 증가하게 된다.

### 🧨 결과

- 성능 저하와 컨텍스트 스위칭 증가가 발생한다.
- waitCount가 과도하게 증가하게 된다.

---

## ✅ 해결 방법: ReentrantLock + Condition

- `ReentrantLock`은 `synchronized`보다 정교한 락 제어가 가능하다.
- `Condition` 객체를 이용하면, 생산자와 소비자 각각을 위한 조건 대기 큐를 분리할 수 있다.
- `signal()` 호출 시, 특정 조건을 기다리는 스레드만 깨울 수 있기 때문에 효율적인 동기화가 가능하다.

---

## 🧪 실습 조건

### 🎯 구현 요구사항

1. 버퍼는 최대 5개의 정수만 저장 가능한 유한 큐로 구현해야 한다.
2. 생산자는 0~100 사이의 랜덤 정수를 생성하여 버퍼에 저장한다.
3. 소비자는 버퍼에서 정수를 꺼내 콘솔에 출력한다.
4. 버퍼가 가득 찼을 경우, 생산자는 생산자 전용 Condition.await()를 통해 대기해야 한다.
5. 버퍼가 비어 있을 경우, 소비자는 소비자 전용 Condition.await()를 통해 대기해야 한다.
6. 생산자가 put()을 완료한 후에는 소비자 Condition을 signal() 해야 한다.
7. 소비자가 take()를 완료한 후에는 생산자 Condition을 signal() 해야 한다.
8. 생산자와 소비자는 각각 2개 이상의 스레드로 구성해야 한다.
9. 프로그램은 약 5초~10초 동안 실행된 후 종료되어야 한다.

## 구현 및 테스트 결과

100 put, 100 get, 5buffer, signal : 95(put먼저), 100(get먼저)
10 put, 10 get, 5buffer, signal : 5(put먼저), 10(get먼저)

## 의의
LockCondition을 활용하여 대기 공간을 분리할 경우 wait에 빠지는 경우를 확연히 줄일 수 있었다.

소비자 스레드가 할 일을 끝내고 다음 스레드를 깨울 때 소비자 or 생산자를 깨우는게 아니라 무조건 생산자를 깨우도록 한다면

하나가 소비되면 하나가 충전되는 경향의 구도를 만들 수 있다.
