# volatile

## 메모리 가시성
java에서 쓰레드1은 쓰레드2를 만들고 그곳에 작업2를 넣어 실행시킨다고 생각해보자.

작업2는 boolean 필드를 가진다.

쓰레드1에서 작업2의 boolean 필드의 값을 변경할 경우 쓰레드2는 이 변화를 일반적으로는 감지할 수 없다.

작업2는 Runnable의 구현체이다. 인스턴스로 존재하니 힙 영역에 존재한다.(메인 메모리에 존재할 것이다.)

그렇기에 쓰레드1, 쓰레드2는 이 힙 영역에서 작업2를 가져와 사용한다.

하지만, 메인 메모리에서 이 작업2를 가져와서 CPU 실행을 하는 것이 아니라

주로 캐시 메모리에 이를 옮겨놓고 사용한다. (현대 CPU는 모두 캐시 메모리를 가진다.)

즉 무언가 사용할 것이 있다면 캐시 메모리에 올려놓고 사용한다는 것이다.

쓰레드1, 쓰레드2가 모두 작업2가 필요하다고 가정해보자.

쓰레드1의 캐시메모리, 쓰레드2의 캐시메모리 두 영역에 작업2가 올라가게 되며,

쓰레드1에서 작업2의 boolean 필드를 수정할 경우 캐시 메모리에 있는 작업2에 대한 수정이 되는 것이다.

즉 이렇기에 쓰레드2에서는 작업2에 대한 boolean 필드를 조회하여도 업데이트가 반영이 안된 필드를 조회하는 것이다.

## volatile

boolean 필드에 volatile 예약어를 주게 되면 수정/읽기에 대해서 항상 메인 메모리를 먼저 읽도록 할 수 있다.

즉 캐시 메모리의 값을 즉각적으로 쓰는 것이 아니라 메인 메모리의 값의 변화를 확인하고 사용한다는 것이다.

### 이해를 위한 예시 시나리오

1. 쓰레드1이 작업2에 대한 volatile boolean runFlag를 true -> false로 바꾼다.
2. 쓰레드1의 캐시 메모리의 작업2에 대한 runFlag값이 바뀌어 저장된다.
3. volatile에 의해 캐시메모리의 runFlag값이 메인 메모리에 곧바로 적용된다.
4. 쓰레드2가 작업2의 runFlag를 읽는다.
5. 읽기전에 메인메모리의 runFlag값을 항상 확인한다.
6. 변화가 존재하기에 이 변화를 쓰레드2의 캐시메모리에 적용하고 읽는다.

항상 확인하고 읽고, 수정시 항상 메인메모리까지 수정해야하므로 비용이 더 소모되지만 변화를 다른 스레드에서도 즉각적으로
인지할 수 있다.

## NoVolatileMultiThreadMain

volatile은 비용적 부분을 양보하고 멀티스레드 상황에서 필드에 대한 즉각적 동기화를 만들어낸다.

volatile을 사용하지 않아서 동기화가 안되어 필드를 읽지 못하는 경우를 코딩해보자.

## VolatileVsNoVolatileMain

volatile의 차이 유무를 더 정확히 드러내기 위해 count를 도입하여 main과 task에서 로그를 찍어보자.

결과 : 실제로 main은 task 스레드에서의 변화를 잘 추적하는 듯 보이지만 아마도 실제 값보단 더 낮은 값을 로깅하고 있을 것이다.

boolean을 한번 변화한 이전 예제와는 달리 count++은 실제로 캐시 메모리까지의 동기화를 일으키는 빈도가 더 잦기에

main이 잘 읽는 듯 보이지만 동기화가 되고 있지 않은 모습이라고 볼 수 있다.

중요한 포인트는 main이 false로 읽었을때의 count와 task가 false로 인지해서 while을 중단한 후의 count 값이 일치하지 않는다는 것이다.

# HappensBefore

보통 HappensBefore 관계에 있다고 표현된다.

예를 들어, 자바의 인터럽트(thread.interrupt())는 HappensBefore 관계에 있다.

자바의 인터럽트 메서드에서의 중요한 로직은 인터럽트 플래그를 바꾸는 것이다.

우리는 volatile을 알고 있고 캐시 메모리 - 메인 메모리 동기화 문제를 알 고 있다.

만약 인터럽트 플래그의 동기화가 보장되지 않는다면, A스레드가 B스레드에 인터럽트를 걸어도 B스레드가 인터럽트 플래그의 변화를 인지하는 것이

의도보다 늦어질 수 있다. 그렇기에 B스레드에서 인터럽트 플래그를 바라보는 로직이 있다면(인터럽트 예외, .interrupted())

누군가가 인터럽트를 걸었을 때 이 바라보는 로직은 곧바로 이 변화를 감지할 수 있어야한다.

volatile, 메모리 가시성 개념으로 이해해보자면 B 스레드의 인터럽트 플래그를 바라보는 로직은 항상 메인 메모리의 인터럽트 플래그를 확인하는 것이 우선되야한다.

## 더 잘 이해해보자.

HappensBefore 관계에 대한 좋은 이해를 위해, 현실 상황에서의 비유를 들어보자.

택배 포장 -> 택배 배송의 로직이 존재한다. 택배 포장이 완료된 이후 택배 배송이 이루어져야한다.

현실세계에선 당연한 로직이지만, 코딩세계에서는 잘못 코딩할 경우 택배 포장 도중 택배 배송이 이루어질 수도 있는 것이다.

즉 단어의 느낌처럼 이전의 행동을 보장해야한다는 것이다.

또 다른 설명으로는 "도중은 없다"라고 해석할 수 있다.

HappensBefore 관계에 있는 기능들은 그 기능이 준비되는 도중에 조회하거나 할 수 없다는 것이다.

즉 중간 참조에 대한 재앙을 막기위해 일관된 원칙을 세운 것이다.

싱글 스레드 기반 코딩에서는 이를 크게 인지할 필요는 없지만, 멀티 스레드에서는 이를 이해해야만 한다.

여러 스레드가 동일한 객체나 데이터를 공유할 때, 순서와 가시성을 보장하지 않으면 예기치 못한 오류가 발생할 수 있기 때문이다.