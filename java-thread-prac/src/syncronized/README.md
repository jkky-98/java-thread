# 🏦 은행 계좌 이체 시스템 - 동시성 제어 과제

## 📌 배경 설명

한 은행에서는 계좌 간 이체 시스템을 개발하고자 한다.  
고객들은 동시에 여러 개의 이체 요청을 보낼 수 있으며, 시스템은 이를 안정적으로 처리해야 한다.

그러나 여러 스레드에서 동시에 같은 계좌에 접근하거나 수정할 수 있기 때문에 **임계 영역 문제가 발생할 수 있다.**

개발자는 Java의 `synchronized` 키워드를 사용하여 이를 제어하려고 한다.

---

## 🎯 목표

- `synchronized` 키워드를 활용해 **계좌 이체 로직에서 발생할 수 있는 동시성 문제**를 해결하라.
- 동시에 여러 스레드가 접근해도 데이터 무결성이 보장되도록 만들어라.
- 또한, `synchronized`의 단점도 확인해보고 **어떤 상황에서 병목(bottleneck)이 생기는지 실험**하라.

---

## ✅ 요구 사항

### 1. 계좌 모델
- `BankAccount` 클래스 생성
    - 필드: `id`, `ownerName`, `balance`
    - 메서드:
        - `deposit(int amount)`
        - `withdraw(int amount)`
        - `transferTo(BankAccount target, int amount)` – 이체 로직

### 2. 동시성 시나리오
- 2개의 계좌 (`A`, `B`) 생성
- `A → B`, `B → A`로 교차 이체가 반복적으로 동시에 일어나야 함
- 각각의 이체는 **다른 스레드**에서 이루어져야 함
- 이체는 여러 번 반복되며, 최종적으로 **두 계좌의 총합은 유지**되어야 함

### 3. 로깅
- 각 이체 시도와 성공 여부를 콘솔에 출력
- 예: `"Thread-1: A → B 이체 시도 (100)"`, `"Thread-1: 이체 성공"`

---

## 💬 질문

- 어떤 경우에 `synchronized`는 불리할 수 있는가?
  - A : Lock을 얻은 스레드가 해당 synchronized 메서드를 실행 중일 때, 다른 스레드또한 이 메서드를 호출하면, BLOCKED 상태로 기다린다.
        여기서 문제가 발생한다. 만약 기다리는 스레드가 여러가지라면 누가 먼저 다음에 이 Lock을 얻어 실행할 것인지 알 수 없으며, 오랫동안 기다릴 수 있다.
        만약 Lock을 가진 스레드가 해당 메서드를 무한히 실행 중이라면, 즉 무한히 Lock을 가지고있다면 -> 기다리는 스레드들은 무한히 기다려야한다.
