# Yield

정확히는 Thread.yield()로 사용가능하며,

직관적인 설명으로는 현재의 스레드 인스턴스가 RUNNABLE 상태를 유지하며 CPU 자원을 양보한다는 것이다.

실제로 JAVA는 Runnable이 실제 실행, 실행준비중 두 가지 영역을 다 커버하지만, 운영체제는 실행상태(Running)과 실행 대기 상태(Ready)로 나누어 구분하는 경우가 많다.

만약 yield()로 양보하지 않고 sleep()을 통해 의도적으로 TIMED_WAITING을 걸어준다고 생각해보자.

이 경우또한 yield()의 목적처럼 현재 쓰레드의 작업의 CPU 실행을 양보하지만, 이는 자바 상태가 변경되는 복잡한 과정을 가치며 지정한 시간만큼 스레드가 실행되지 않는 단점이 존재한다.

사실 양보할 스레드가 없다면 .yield()를 먹더라도 계속 실행되어야 한다. 반면 sleep()을 활용할 경우 그렇지 않다.

## YieldVsSleepMain

100개의 쓰레드를 만들어 같은 작업을 수행시킬 것이다.

수행 시킬 작업은 간단한 문자열 반복 출력이며 "쓰레드이름 - i" (i = 0~999) 이다.

1. 반복문안에 Thread.yield()를 사용하여 작업이 기존보다 더욱 고르게 수행되도록 할 것이다.
수행된 시간을 출력한다.
2. 반복문안에 sleep(1)를 사용하여 작업이 기존보다 더욱 고르게 수행되도록 할 것이다.
수행된 시간을 출력한다.